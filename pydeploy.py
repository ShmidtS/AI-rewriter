#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
pydeploy.py â€” Universal Environment Synchronizer (v5.0.0)
Ultimate Edition - Production Ready

Ğ¤ÑƒĞ½ĞºÑ†Ğ¸Ğ¸:
1. Scan & Map: Ğ£Ğ¼Ğ½Ğ¾Ğµ ÑĞºĞ°Ğ½Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ¸Ğ¼Ğ¿Ğ¾Ñ€Ñ‚Ğ¾Ğ² Ğ¸ Ğ¼Ğ°Ğ¿Ğ¿Ğ¸Ğ½Ğ³ Ğ¸Ğ¼ĞµĞ½ Ğ¿Ğ°ĞºĞµÑ‚Ğ¾Ğ²
2. Sync State: Ğ£ÑÑ‚Ğ°Ğ½Ğ¾Ğ²ĞºĞ° Ğ½ÑƒĞ¶Ğ½Ğ¾Ğ³Ğ¾, Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¸Ğµ ÑÑ‚Ğ°Ñ€Ğ¾Ğ³Ğ¾, Ğ£Ğ”ĞĞ›Ğ•ĞĞ˜Ğ• Ğ›Ğ˜Ğ¨ĞĞ•Ğ“Ğ
3. Lock: Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ Ğ²Ğ¾ÑĞ¿Ñ€Ğ¾Ğ¸Ğ·Ğ²Ğ¾Ğ´Ğ¸Ğ¼Ğ¾Ğ³Ğ¾ requirements.lock
4. Verify: ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ñ†ĞµĞ»Ğ¾ÑÑ‚Ğ½Ğ¾ÑÑ‚Ğ¸ Ğ¾ĞºÑ€ÑƒĞ¶ĞµĞ½Ğ¸Ñ Ğ¿Ğ¾ÑĞ»Ğµ ÑƒÑÑ‚Ğ°Ğ½Ğ¾Ğ²ĞºĞ¸
5. Binary Force: ĞŸĞ¾Ğ´Ğ´ĞµÑ€Ğ¶ĞºĞ° ÑĞ»Ğ¾Ğ¶Ğ½Ñ‹Ñ… ÑĞ»ÑƒÑ‡Ğ°ĞµĞ² (Python 3.13, Windows)
6. Prune: Ğ£Ğ¼Ğ½Ğ¾Ğµ ÑƒĞ´Ğ°Ğ»ĞµĞ½Ğ¸Ğµ Ğ½ĞµĞ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞµĞ¼Ñ‹Ñ… Ğ·Ğ°Ğ²Ğ¸ÑĞ¸Ğ¼Ğ¾ÑÑ‚ĞµĞ¹
7. Backup/Restore: Ğ ĞµĞ·ĞµÑ€Ğ²Ğ½Ğ¾Ğµ ĞºĞ¾Ğ¿Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ ÑĞ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸Ñ Ğ¾ĞºÑ€ÑƒĞ¶ĞµĞ½Ğ¸Ñ

Ğ—Ğ°Ğ¿ÑƒÑĞº:
    python pydeploy.py          -> Ğ¡Ğ¸Ğ½Ñ…Ñ€Ğ¾Ğ½Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ (Install/Uninstall)
    python pydeploy.py update   -> ĞŸÑ€Ğ¸Ğ½ÑƒĞ´Ğ¸Ñ‚ĞµĞ»ÑŒĞ½Ğ¾Ğµ Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¸Ğµ Ğ²ÑĞµĞ³Ğ¾ Ğ´Ğ¾ Fresh
    python pydeploy.py verify   -> ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ñ†ĞµĞ»Ğ¾ÑÑ‚Ğ½Ğ¾ÑÑ‚Ğ¸ (pip check)
    python pydeploy.py prune    -> Ğ£Ğ´Ğ°Ğ»ĞµĞ½Ğ¸Ğµ Ğ½ĞµĞ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞµĞ¼Ñ‹Ñ… Ğ¿Ğ°ĞºĞµÑ‚Ğ¾Ğ²
    python pydeploy.py backup   -> Ğ ĞµĞ·ĞµÑ€Ğ²Ğ½Ğ¾Ğµ ĞºĞ¾Ğ¿Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ¾ĞºÑ€ÑƒĞ¶ĞµĞ½Ğ¸Ñ
    python pydeploy.py restore  -> Ğ’Ğ¾ÑÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¸Ğµ Ğ¸Ğ· Ñ€ĞµĞ·ĞµÑ€Ğ²Ğ½Ğ¾Ğ¹ ĞºĞ¾Ğ¿Ğ¸Ğ¸
"""

import sys
import subprocess
import shutil
import ast
import logging
import time
import urllib.request
import platform
import sysconfig
import os
import json
import hashlib
from pathlib import Path
from typing import List, Set, Dict, Tuple, Optional, Union
from datetime import datetime

VERSION = "5.0.0"
VENV_NAME = ".venv"
LOCK_FILE = "requirements.lock"
REQ_FILE = "requirements.txt"
LOG_FILE = "deploy.log"
BACKUP_DIR = ".pydeploy_backups"
CACHE_FILE = ".pydeploy_cache.json"
REMOTE_MAPPING_URL = "https://raw.githubusercontent.com/bndr/pipreqs/master/pipreqs/mapping"
CACHE_EXPIRY_DAYS = 7
MAX_PACKAGE_NAME_LENGTH = 214  # PyPI limit

# Hardcoded mapping (Ğ¡Ğ°Ğ¼Ñ‹Ğµ Ñ‡Ğ°ÑÑ‚Ñ‹Ğµ Ğ¾ÑˆĞ¸Ğ±ĞºĞ¸)
KNOWN_MAPPING = {
    "mdbx": "libmdbx", "cv2": "opencv-python", "skimage": "scikit-image",
    "PIL": "Pillow", "yaml": "PyYAML", "bs4": "beautifulsoup4",
    "dotenv": "python-dotenv", "sklearn": "scikit-learn",
    "telegram": "python-telegram-bot", "mysqldb": "mysqlclient",
    "fitz": "pymupdf", "docx": "python-docx", "discord": "discord.py",
    "dateutil": "python-dateutil", "dns": "dnspython",
    "psycopg2": "psycopg2-binary", "magic": "python-magic",
    "genai": "google.generativeai"
}

# ANSI Color Codes Ğ´Ğ»Ñ ĞºÑ€Ğ°ÑĞ¸Ğ²Ğ¾Ğ³Ğ¾ Ğ²Ñ‹Ğ²Ğ¾Ğ´Ğ°
class Colors:
    RESET = "\033[0m"
    BOLD = "\033[1m"
    RED = "\033[91m"
    GREEN = "\033[92m"
    YELLOW = "\033[93m"
    BLUE = "\033[94m"
    MAGENTA = "\033[95m"
    CYAN = "\033[96m"
    
    @staticmethod
    def disable_on_windows():
        """ĞÑ‚ĞºĞ»ÑÑ‡Ğ¸Ñ‚ÑŒ Ñ†Ğ²ĞµÑ‚Ğ° Ğ½Ğ° ÑÑ‚Ğ°Ñ€Ñ‹Ñ… Windows Ñ‚ĞµÑ€Ğ¼Ğ¸Ğ½Ğ°Ğ»Ğ°Ñ…"""
        if sys.platform == "win32":
            try:
                import ctypes
                kernel32 = ctypes.windll.kernel32
                kernel32.SetConsoleMode(kernel32.GetStdHandle(-11), 7)
            except (OSError, AttributeError, ImportError):
                for attr in dir(Colors):
                    if not attr.startswith('_') and attr != 'disable_on_windows':
                        setattr(Colors, attr, '')

Colors.disable_on_windows()

# ĞĞ°ÑÑ‚Ñ€Ğ¾Ğ¹ĞºĞ° Ğ»Ğ¾Ğ³Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s | %(levelname)-8s | %(message)s",
    handlers=[
        logging.FileHandler(LOG_FILE, encoding="utf-8"),
        logging.StreamHandler(sys.stdout)
    ]
)
log = logging.getLogger("pydeploy")

# ĞĞ¿Ñ€ĞµĞ´ĞµĞ»ĞµĞ½Ğ¸Ğµ Ğ¿ÑƒÑ‚Ğ¸ Ğº Python Ğ² venv
if sys.platform == "win32":
    VENV_PYTHON = Path(VENV_NAME) / "Scripts" / "python.exe"
    VENV_PIP = Path(VENV_NAME) / "Scripts" / "pip.exe"
else:
    VENV_PYTHON = Path(VENV_NAME) / "bin" / "python"
    VENV_PIP = Path(VENV_NAME) / "bin" / "pip"

# Ğ˜Ğ¼Ğ¿Ğ¾Ñ€Ñ‚ packages_distributions (Ñ fallback)
try:
    from importlib.metadata import packages_distributions, distributions
except ImportError:
    def packages_distributions():
        return {}
    def distributions():
        return []


def run(cmd: List[str], cwd: Optional[Path] = None, capture: bool = True, 
        timeout: int = 300) -> subprocess.CompletedProcess:
    """Ğ’Ñ‹Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ¸Ğµ ĞºĞ¾Ğ¼Ğ°Ğ½Ğ´Ñ‹ Ñ Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ¾Ğ¹ Ğ¾ÑˆĞ¸Ğ±Ğ¾Ğº"""
    if not cmd:
        return subprocess.CompletedProcess(cmd, 1, "", "Empty command")
    
    try:
        return subprocess.run(
            cmd, 
            cwd=cwd or Path.cwd(), 
            capture_output=capture, 
            text=True, 
            encoding="utf-8", 
            errors="replace",
            timeout=timeout,
            check=False
        )
    except FileNotFoundError:
        log.error(f"Command not found: {cmd[0]}")
        return subprocess.CompletedProcess(cmd, 1, "", f"Exec not found: {cmd[0]}")
    except subprocess.TimeoutExpired:
        log.warning(f"Command timeout: {' '.join(cmd)}")
        return subprocess.CompletedProcess(cmd, 1, "", f"Timeout: {' '.join(cmd)}")
    except (OSError, ValueError) as e:
        log.error(f"Command execution error: {e}")
        return subprocess.CompletedProcess(cmd, 1, "", f"Error: {e}")


def print_banner(text: str, color: str = Colors.CYAN) -> None:
    """ĞšÑ€Ğ°ÑĞ¸Ğ²Ñ‹Ğ¹ Ğ±Ğ°Ğ½Ğ½ĞµÑ€"""
    if not text:
        return
    print(f"\n{color}{'â•'*70}{Colors.RESET}")
    print(f"{color}{Colors.BOLD} {text}{Colors.RESET}")
    print(f"{color}{'â•'*70}{Colors.RESET}")


def print_status(symbol: str, text: str, color: str = Colors.RESET) -> None:
    """Ğ’Ñ‹Ğ²Ğ¾Ğ´ ÑÑ‚Ğ°Ñ‚ÑƒÑĞ° Ñ ÑĞ¸Ğ¼Ğ²Ğ¾Ğ»Ğ¾Ğ¼ Ğ¸ Ñ†Ğ²ĞµÑ‚Ğ¾Ğ¼"""
    if not text:
        return
    print(f"{color}{symbol} {text}{Colors.RESET}")


def find_uv_executable() -> str:
    """ĞŸĞ¾Ğ¸ÑĞº Ğ¸ÑĞ¿Ğ¾Ğ»Ğ½ÑĞµĞ¼Ğ¾Ğ³Ğ¾ Ñ„Ğ°Ğ¹Ğ»Ğ° uv"""
    if shutil.which("uv"):
        return shutil.which("uv")
    
    filename = "uv.exe" if sys.platform == "win32" else "uv"
    candidates = []
    
    # Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ»ÑĞµĞ¼ Ñ€Ğ°Ğ·Ğ»Ğ¸Ñ‡Ğ½Ñ‹Ğµ Ğ²Ğ¾Ğ·Ğ¼Ğ¾Ğ¶Ğ½Ñ‹Ğµ Ğ¿ÑƒÑ‚Ğ¸
    try:
        candidates.append(Path(sysconfig.get_path("scripts")))
    except (KeyError, ValueError, AttributeError):
        pass
    
    try:
        scheme = "nt_user" if os.name == 'nt' else "posix_user"
        candidates.append(Path(sysconfig.get_path("scripts", scheme=scheme)))
    except (KeyError, ValueError, AttributeError):
        pass
    
    candidates.extend([
        Path(sys.executable).parent,
        Path(sys.executable).parent / "Scripts",
        Path.home() / ".local" / "bin",
        Path.home() / ".cargo" / "bin"
    ])
    
    for path in candidates:
        if path and (path / filename).exists():
            return str(path / filename)
    
    return "uv"


def ensure_uv():
    """Ğ£ÑÑ‚Ğ°Ğ½Ğ¾Ğ²ĞºĞ° uv, ĞµÑĞ»Ğ¸ ĞµĞ³Ğ¾ Ğ½ĞµÑ‚"""
    uv_path = find_uv_executable()
    if Path(uv_path).exists() and Path(uv_path).is_file():
        return
    if shutil.which("uv"):
        return
    
    print_status("ğŸ“¦", "Installing UV package manager...", Colors.YELLOW)
    cmd = [sys.executable, "-m", "pip", "install", "--user", "uv"]
    
    # Ğ•ÑĞ»Ğ¸ Ğ¼Ñ‹ Ğ² venv, ÑÑ‚Ğ°Ğ²Ğ¸Ğ¼ Ğ±ĞµĞ· --user
    if sys.prefix != sys.base_prefix:
        cmd = [sys.executable, "-m", "pip", "install", "uv"]
    
    result = run(cmd, capture=False)
    if result.returncode != 0:
        log.warning("Failed to install UV, will use pip as fallback")


def run_uv(args: List[str], capture: bool = True, timeout: int = 300) -> subprocess.CompletedProcess:
    """Ğ’Ñ‹Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ¸Ğµ ĞºĞ¾Ğ¼Ğ°Ğ½Ğ´Ñ‹ Ñ‡ĞµÑ€ĞµĞ· uv"""
    uv = find_uv_executable()
    if uv == "uv" and not shutil.which("uv"):
        return subprocess.CompletedProcess(args, 1, "", "UV missing")
    return run([uv] + args, capture=capture, timeout=timeout)


def create_venv() -> bool:
    """Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ Ğ²Ğ¸Ñ€Ñ‚ÑƒĞ°Ğ»ÑŒĞ½Ğ¾Ğ³Ğ¾ Ğ¾ĞºÑ€ÑƒĞ¶ĞµĞ½Ğ¸Ñ"""
    if VENV_PYTHON.exists():
        print_status("âœ“", f"Virtual environment exists: {VENV_NAME}", Colors.GREEN)
        return True
    
    print_banner("Creating Virtual Environment", Colors.BLUE)
    ensure_uv()
    
    # ĞŸĞ¾Ğ¿Ñ‹Ñ‚ĞºĞ° Ñ‡ĞµÑ€ĞµĞ· uv (Ğ±Ñ‹ÑÑ‚Ñ€ĞµĞµ)
    result = run_uv(["venv", VENV_NAME], capture=False)
    if result.returncode == 0:
        print_status("âœ“", "Virtual environment created with UV", Colors.GREEN)
        return True
    
    # Fallback Ğ½Ğ° ÑÑ‚Ğ°Ğ½Ğ´Ğ°Ñ€Ñ‚Ğ½Ñ‹Ğ¹ venv
    print_status("âš ", "UV failed, falling back to standard venv...", Colors.YELLOW)
    result = run([sys.executable, "-m", "venv", VENV_NAME], capture=False)
    
    if result.returncode == 0:
        print_status("âœ“", "Virtual environment created", Colors.GREEN)
        return True
    
    print_status("âœ—", "Failed to create virtual environment", Colors.RED)
    return False


def get_stdlib() -> Set[str]:
    """ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğµ ÑĞ¿Ğ¸ÑĞºĞ° Ğ¼Ğ¾Ğ´ÑƒĞ»ĞµĞ¹ ÑÑ‚Ğ°Ğ½Ğ´Ğ°Ñ€Ñ‚Ğ½Ğ¾Ğ¹ Ğ±Ğ¸Ğ±Ğ»Ğ¸Ğ¾Ñ‚ĞµĞºĞ¸"""
    stdlib = {
        "abc", "argparse", "ast", "asyncio", "base64", "collections", "concurrent", 
        "contextlib", "copy", "csv", "dataclasses", "datetime", "decimal", "email", 
        "enum", "functools", "glob", "gzip", "hashlib", "html", "http", "importlib", 
        "inspect", "io", "itertools", "json", "logging", "math", "multiprocessing",
        "operator", "os", "pathlib", "pickle", "platform", "pprint", "queue", "random", 
        "re", "shutil", "signal", "socket", "sqlite3", "ssl", "stat", "string", "struct", 
        "subprocess", "sys", "tempfile", "threading", "time", "tkinter", "tokenize", 
        "traceback", "types", "typing", "unittest", "urllib", "uuid", "warnings", 
        "weakref", "xml", "zipfile", "zlib", "zoneinfo", "array", "binascii", "builtins",
        "cmath", "codecs", "crypt", "curses", "dbm", "difflib", "dis", "distutils",
        "fcntl", "filecmp", "fnmatch", "formatter", "fractions", "ftplib", "getopt",
        "getpass", "gettext", "grp", "heapq", "hmac", "imaplib", "imp", "keyword",
        "linecache", "locale", "mailbox", "mailcap", "marshal", "mimetypes", "mmap",
        "modulefinder", "msilib", "msvcrt", "netrc", "nis", "nntplib", "numbers",
        "optparse", "ossaudiodev", "parser", "pdb", "pipes", "pkgutil", "poplib",
        "posix", "posixpath", "pwd", "py_compile", "pyclbr", "pydoc", "pyexpat",
        "quopri", "readline", "reprlib", "resource", "rlcompleter", "runpy", "sched",
        "secrets", "select", "selectors", "shelve", "site", "smtpd", "smtplib",
        "sndhdr", "socketserver", "spwd", "statistics", "stringprep", "sunau",
        "symbol", "symtable", "syslog", "tabnanny", "tarfile", "telnetlib", "termios",
        "test", "textwrap", "this", "timeit", "token", "tomllib", "trace", "tty",
        "turtle", "turtledemo", "unicodedata", "unittest", "uu", "venv", "wave",
        "webbrowser", "winreg", "winsound", "wsgiref", "xdrlib", "xmlrpc", "zipapp",
        "zipimport", "_thread"
    }
    
    # Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞµĞ¼ sys.stdlib_module_names ĞµÑĞ»Ğ¸ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ğ¾ (Python 3.10+)
    if hasattr(sys, 'stdlib_module_names'):
        stdlib.update(sys.stdlib_module_names)
    
    return stdlib


def load_cached_mapping() -> Dict[str, str]:
    """Ğ—Ğ°Ğ³Ñ€ÑƒĞ·ĞºĞ° ĞºÑÑˆĞ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ğ¾Ğ³Ğ¾ Ğ¼Ğ°Ğ¿Ğ¿Ğ¸Ğ½Ğ³Ğ°"""
    if not Path(CACHE_FILE).exists():
        return {}
    
    try:
        with open(CACHE_FILE, 'r', encoding='utf-8') as f:
            cache = json.load(f)
            # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ ÑÑ€Ğ¾Ğº Ğ´Ğ°Ğ²Ğ½Ğ¾ÑÑ‚Ğ¸ ĞºÑÑˆĞ°
            cache_time = cache.get('timestamp', 0)
            if time.time() - cache_time < CACHE_EXPIRY_DAYS * 24 * 3600:
                return cache.get('mapping', {})
    except (FileNotFoundError, json.JSONDecodeError, KeyError, ValueError) as e:
        log.debug(f"Failed to load cache: {e}")
    
    return {}


def save_cached_mapping(mapping: Dict[str, str]) -> None:
    """Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ¸Ğµ Ğ¼Ğ°Ğ¿Ğ¿Ğ¸Ğ½Ğ³Ğ° Ğ² ĞºÑÑˆ"""
    if not mapping:
        return
    try:
        cache = {
            'timestamp': time.time(),
            'mapping': mapping
        }
        with open(CACHE_FILE, 'w', encoding='utf-8') as f:
            json.dump(cache, f, indent=2)
    except (OSError, PermissionError, json.JSONEncodeError) as e:
        log.warning(f"Failed to save cache: {e}")


def validate_package_name(name: str) -> bool:
    """Ğ’Ğ°Ğ»Ğ¸Ğ´Ğ°Ñ†Ğ¸Ñ Ğ¸Ğ¼ĞµĞ½Ğ¸ Ğ¿Ğ°ĞºĞµÑ‚Ğ° ÑĞ¾Ğ³Ğ»Ğ°ÑĞ½Ğ¾ PEP 508"""
    if not name or not isinstance(name, str):
        return False
    if len(name) > MAX_PACKAGE_NAME_LENGTH:
        return False
    # Ğ‘Ğ°Ğ·Ğ¾Ğ²Ñ‹Ğµ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºĞ¸: Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ğ±ÑƒĞºĞ²Ñ‹, Ñ†Ğ¸Ñ„Ñ€Ñ‹, Ğ´ĞµÑ„Ğ¸ÑÑ‹, Ğ¿Ğ¾Ğ´Ñ‡ĞµÑ€ĞºĞ¸Ğ²Ğ°Ğ½Ğ¸Ñ, Ñ‚Ğ¾Ñ‡ĞºĞ¸
    if not all(c.isalnum() or c in ('-', '_', '.') for c in name):
        return False
    return True


def resolve_mapping(imports: Set[str]) -> List[str]:
    """ĞŸÑ€ĞµĞ¾Ğ±Ñ€Ğ°Ğ·Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ¸Ğ¼Ñ‘Ğ½ Ğ¼Ğ¾Ğ´ÑƒĞ»ĞµĞ¹ Ğ² Ğ¸Ğ¼ĞµĞ½Ğ° Ğ¿Ğ°ĞºĞµÑ‚Ğ¾Ğ² PyPI"""
    if not imports:
        return []
    
    resolved = set()
    unknown = []
    
    # ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ Ğ»Ğ¾ĞºĞ°Ğ»ÑŒĞ½Ñ‹Ğ¹ Ğ¼Ğ°Ğ¿Ğ¿Ğ¸Ğ½Ğ³ Ñ Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ¾Ğ¹ Ğ¾ÑˆĞ¸Ğ±Ğ¾Ğº
    try:
        local_dist = packages_distributions()
    except Exception as e:
        log.debug(f"Failed to get local distributions: {e}")
        local_dist = {}
    
    # Ğ¡Ğ½Ğ°Ñ‡Ğ°Ğ»Ğ° Ğ¿Ñ€Ğ¾Ğ±ÑƒĞµĞ¼ Ğ»Ğ¾ĞºĞ°Ğ»ÑŒĞ½Ñ‹Ğ¹ Ğ¼Ğ°Ğ¿Ğ¿Ğ¸Ğ½Ğ³ Ñ‡ĞµÑ€ĞµĞ· importlib
    for mod in imports:
        if not mod or not isinstance(mod, str):
            continue
        # Ğ’Ğ°Ğ»Ğ¸Ğ´Ğ°Ñ†Ğ¸Ñ Ğ¸Ğ¼ĞµĞ½Ğ¸ Ğ¼Ğ¾Ğ´ÑƒĞ»Ñ
        if not validate_package_name(mod):
            log.debug(f"Invalid module name: {mod}")
            continue
        if mod in local_dist:
            dist_list = local_dist[mod]
            if dist_list:
                resolved.add(dist_list[0])
        elif mod in KNOWN_MAPPING:
            resolved.add(KNOWN_MAPPING[mod])
        else:
            unknown.append(mod)
    
    # Ğ•ÑĞ»Ğ¸ ĞµÑÑ‚ÑŒ Ğ½ĞµĞ¸Ğ·Ğ²ĞµÑÑ‚Ğ½Ñ‹Ğµ Ğ¼Ğ¾Ğ´ÑƒĞ»Ğ¸, Ğ¿Ñ€Ğ¾Ğ±ÑƒĞµĞ¼ Ğ·Ğ°Ğ³Ñ€ÑƒĞ·Ğ¸Ñ‚ÑŒ remote mapping
    if unknown:
        cached_mapping = load_cached_mapping()
        remote_mapping = {}
        
        # ĞŸÑ€Ğ¾Ğ±ÑƒĞµĞ¼ Ğ·Ğ°Ğ³Ñ€ÑƒĞ·Ğ¸Ñ‚ÑŒ Ğ¸Ğ· ÑĞµÑ‚Ğ¸
        try:
            with urllib.request.urlopen(REMOTE_MAPPING_URL, timeout=2.0) as r:
                if r.status != 200:
                    raise urllib.error.HTTPError(REMOTE_MAPPING_URL, r.status, 
                                                "HTTP Error", r.headers, None)
                data = r.read().decode("utf-8")
                for line in data.splitlines():
                    if ":" in line:
                        parts = line.split(":", 1)
                        if len(parts) == 2:
                            remote_mapping[parts[0].strip()] = parts[1].strip()
                
                # Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½ÑĞµĞ¼ Ğ² ĞºÑÑˆ
                save_cached_mapping(remote_mapping)
        except (urllib.error.URLError, urllib.error.HTTPError, 
                TimeoutError, UnicodeDecodeError) as e:
            log.debug(f"Failed to fetch remote mapping: {e}")
            remote_mapping = cached_mapping
        
        # Ğ Ğ°Ğ·Ñ€ĞµÑˆĞ°ĞµĞ¼ Ğ½ĞµĞ¸Ğ·Ğ²ĞµÑÑ‚Ğ½Ñ‹Ğµ Ğ¼Ğ¾Ğ´ÑƒĞ»Ğ¸
        for mod in unknown:
            if mod in remote_mapping:
                pkg_name = remote_mapping[mod]
                if validate_package_name(pkg_name):
                    resolved.add(pkg_name)
            elif mod in cached_mapping:
                pkg_name = cached_mapping[mod]
                if validate_package_name(pkg_name):
                    resolved.add(pkg_name)
            else:
                # ĞŸĞ¾ÑĞ»ĞµĞ´Ğ½ÑÑ Ğ½Ğ°Ğ´ĞµĞ¶Ğ´Ğ° - ÑĞ°Ğ¼ Ğ¼Ğ¾Ğ´ÑƒĞ»ÑŒ ÑÑ‚Ğ¾ Ğ¸ ĞµÑÑ‚ÑŒ Ğ¸Ğ¼Ñ Ğ¿Ğ°ĞºĞµÑ‚Ğ°
                if validate_package_name(mod):
                    resolved.add(mod)
                    log.debug(f"Unknown module mapping: {mod} -> assuming package name")
                else:
                    log.warning(f"Skipping invalid package name: {mod}")
    
    return sorted(list(resolved))


def scan_project() -> List[str]:
    """Ğ¡ĞºĞ°Ğ½Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ¿Ñ€Ğ¾ĞµĞºÑ‚Ğ° Ğ½Ğ° Ğ½Ğ°Ğ»Ğ¸Ñ‡Ğ¸Ğµ Ğ¸Ğ¼Ğ¿Ğ¾Ñ€Ñ‚Ğ¾Ğ²"""
    print_banner("Scanning Project Imports", Colors.BLUE)
    
    imports = set()
    ignore = {VENV_NAME, "__pycache__", ".git", ".idea", ".vscode", 
              "build", "dist", ".pytest_cache", ".mypy_cache", "node_modules"}
    
    # ĞšÑÑˆĞ¸Ñ€ÑƒĞµĞ¼ Ğ¸Ğ¼Ñ Ñ‚ĞµĞºÑƒÑ‰ĞµĞ³Ğ¾ Ñ„Ğ°Ğ¹Ğ»Ğ°
    current_file_name = Path(__file__).name
    
    py_files = list(Path.cwd().rglob("*.py"))
    print_status("ğŸ“", f"Found {len(py_files)} Python files", Colors.CYAN)
    
    for py_file in py_files:
        # Ğ˜Ğ³Ğ½Ğ¾Ñ€Ğ¸Ñ€ÑƒĞµĞ¼ Ñ„Ğ°Ğ¹Ğ»Ñ‹ Ğ² Ğ¸ÑĞºĞ»ÑÑ‡Ñ‘Ğ½Ğ½Ñ‹Ñ… Ğ´Ğ¸Ñ€ĞµĞºÑ‚Ğ¾Ñ€Ğ¸ÑÑ… (Ğ¾Ğ¿Ñ‚Ğ¸Ğ¼Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ)
        if any(ignored in py_file.parts for ignored in ignore):
            continue
        
        # Ğ˜Ğ³Ğ½Ğ¾Ñ€Ğ¸Ñ€ÑƒĞµĞ¼ ÑĞ°Ğ¼ ÑĞºÑ€Ğ¸Ğ¿Ñ‚ pydeploy
        if py_file.name == current_file_name:
            continue
        
        try:
            content = py_file.read_text(encoding="utf-8", errors="ignore")
            tree = ast.parse(content, filename=str(py_file))
            
            for node in ast.walk(tree):
                if isinstance(node, ast.Import):
                    for alias in node.names:
                        module_name = alias.name.split('.')[0]
                        imports.add(module_name)
                
                elif isinstance(node, ast.ImportFrom):
                    if node.module:
                        module_name = node.module.split('.')[0]
                        imports.add(module_name)
        
        except SyntaxError as e:
            log.warning(f"Syntax error in {py_file}: {e}, skipping")
        except (UnicodeDecodeError, PermissionError, OSError) as e:
            log.debug(f"Failed to parse {py_file}: {e}")
    
    # Ğ¤Ğ¸Ğ»ÑŒÑ‚Ñ€ÑƒĞµĞ¼ stdlib Ğ¸ private Ğ¼Ğ¾Ğ´ÑƒĞ»Ğ¸
    stdlib = get_stdlib()
    external = {i for i in imports if i not in stdlib and not i.startswith("_")}
    
    print_status("ğŸ”", f"Found {len(external)} external dependencies", Colors.CYAN)
    
    # ĞŸÑ€ĞµĞ¾Ğ±Ñ€Ğ°Ğ·ÑƒĞµĞ¼ Ğ² Ğ¸Ğ¼ĞµĞ½Ğ° Ğ¿Ğ°ĞºĞµÑ‚Ğ¾Ğ²
    packages = resolve_mapping(external)
    
    for pkg in packages:
        print_status("  â€¢", pkg, Colors.RESET)
    
    return packages


def get_installed_packages() -> Dict[str, str]:
    """ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğµ ÑƒÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ½Ñ‹Ñ… Ğ¿Ğ°ĞºĞµÑ‚Ğ¾Ğ² Ñ Ğ²ĞµÑ€ÑĞ¸ÑĞ¼Ğ¸"""
    result = run_uv(["pip", "freeze", "--python", str(VENV_PYTHON)], capture=True)
    
    if result.returncode != 0:
        # Fallback Ğ½Ğ° Ğ¾Ğ±Ñ‹Ñ‡Ğ½Ñ‹Ğ¹ pip
        result = run([str(VENV_PYTHON), "-m", "pip", "freeze"], capture=True)
    
    if result.returncode != 0:
        log.warning("Failed to get installed packages list")
        return {}
    
    packages = {}
    for line in result.stdout.splitlines():
        line = line.strip()
        if not line or line.startswith('#'):
            continue
        
        try:
            if "==" in line:
                name, version = line.split("==", 1)
                packages[name.lower().strip()] = version.strip()
            elif "@" in line:
                # ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° URL Ğ·Ğ°Ğ²Ğ¸ÑĞ¸Ğ¼Ğ¾ÑÑ‚ĞµĞ¹ (git+https://...)
                name = line.split("@")[0].strip()
                if name:
                    packages[name.lower()] = "url"
        except ValueError:
            log.debug(f"Failed to parse package line: {line}")
            continue
    
    return packages


def get_package_dependencies(package: str) -> Set[str]:
    """ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğµ Ğ·Ğ°Ğ²Ğ¸ÑĞ¸Ğ¼Ğ¾ÑÑ‚ĞµĞ¹ ĞºĞ¾Ğ½ĞºÑ€ĞµÑ‚Ğ½Ğ¾Ğ³Ğ¾ Ğ¿Ğ°ĞºĞµÑ‚Ğ°"""
    result = run([str(VENV_PYTHON), "-m", "pip", "show", package], capture=True)
    
    if result.returncode != 0:
        log.debug(f"Package {package} not found or error getting info")
        return set()
    
    dependencies = set()
    for line in result.stdout.splitlines():
        if line.startswith("Requires:"):
            try:
                deps_str = line.split(":", 1)[1].strip()
                if deps_str:
                    dependencies = {d.strip().lower() for d in deps_str.split(",") if d.strip()}
            except (IndexError, ValueError):
                log.debug(f"Failed to parse dependencies for {package}")
            break
    
    return dependencies


def build_dependency_tree() -> Dict[str, Set[str]]:
    """ĞŸĞ¾ÑÑ‚Ñ€Ğ¾ĞµĞ½Ğ¸Ğµ Ğ´ĞµÑ€ĞµĞ²Ğ° Ğ·Ğ°Ğ²Ğ¸ÑĞ¸Ğ¼Ğ¾ÑÑ‚ĞµĞ¹ Ğ²ÑĞµÑ… ÑƒÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ½Ñ‹Ñ… Ğ¿Ğ°ĞºĞµÑ‚Ğ¾Ğ²"""
    installed = get_installed_packages()
    tree = {}
    
    # ĞšÑÑˆĞ¸Ñ€ÑƒĞµĞ¼ Ñ€ĞµĞ·ÑƒĞ»ÑŒÑ‚Ğ°Ñ‚Ñ‹ Ğ´Ğ»Ñ Ğ¾Ğ¿Ñ‚Ğ¸Ğ¼Ğ¸Ğ·Ğ°Ñ†Ğ¸Ğ¸
    for package in installed.keys():
        deps = get_package_dependencies(package)
        if deps:  # Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½ÑĞµĞ¼ Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ğ½ĞµĞ¿ÑƒÑÑ‚Ñ‹Ğµ Ğ·Ğ°Ğ²Ğ¸ÑĞ¸Ğ¼Ğ¾ÑÑ‚Ğ¸
            tree[package] = deps
    
    return tree


def find_orphaned_packages(required: List[str], installed: Dict[str, str]) -> List[str]:
    """ĞŸĞ¾Ğ¸ÑĞº Ğ¿Ğ°ĞºĞµÑ‚Ğ¾Ğ², ĞºĞ¾Ñ‚Ğ¾Ñ€Ñ‹Ğµ Ğ½Ğµ Ğ½ÑƒĞ¶Ğ½Ñ‹ (Ğ½Ğµ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒÑÑ‚ÑÑ Ğ¸ Ğ½Ğµ ÑĞ²Ğ»ÑÑÑ‚ÑÑ Ğ·Ğ°Ğ²Ğ¸ÑĞ¸Ğ¼Ğ¾ÑÑ‚ÑĞ¼Ğ¸)"""
    if not installed:
        return []
    
    required_lower = {pkg.lower() for pkg in required if pkg}
    installed_lower = set(installed.keys())
    
    # Ğ¡Ñ‚Ñ€Ğ¾Ğ¸Ğ¼ Ğ´ĞµÑ€ĞµĞ²Ğ¾ Ğ·Ğ°Ğ²Ğ¸ÑĞ¸Ğ¼Ğ¾ÑÑ‚ĞµĞ¹
    dep_tree = build_dependency_tree()
    
    # ĞĞ°Ñ…Ğ¾Ğ´Ğ¸Ğ¼ Ğ²ÑĞµ Ñ‚Ñ€Ğ°Ğ½Ğ·Ğ¸Ñ‚Ğ¸Ğ²Ğ½Ñ‹Ğµ Ğ·Ğ°Ğ²Ğ¸ÑĞ¸Ğ¼Ğ¾ÑÑ‚Ğ¸ Ñ‚Ñ€ĞµĞ±ÑƒĞµĞ¼Ñ‹Ñ… Ğ¿Ğ°ĞºĞµÑ‚Ğ¾Ğ²
    needed = set(required_lower)
    to_process = list(required_lower)
    processed = set()  # Ğ—Ğ°Ñ‰Ğ¸Ñ‚Ğ° Ğ¾Ñ‚ Ñ†Ğ¸ĞºĞ»Ğ¸Ñ‡ĞµÑĞºĞ¸Ñ… Ğ·Ğ°Ğ²Ğ¸ÑĞ¸Ğ¼Ğ¾ÑÑ‚ĞµĞ¹
    
    while to_process:
        pkg = to_process.pop()
        if pkg in processed:
            continue
        processed.add(pkg)
        
        if pkg in dep_tree:
            for dep in dep_tree[pkg]:
                if dep not in needed and dep in installed_lower:
                    needed.add(dep)
                    to_process.append(dep)
    
    # ĞŸĞ°ĞºĞµÑ‚Ñ‹, ĞºĞ¾Ñ‚Ğ¾Ñ€Ñ‹Ñ… Ğ½ĞµÑ‚ Ğ½Ğ¸ Ğ² Ñ‚Ñ€ĞµĞ±ÑƒĞµĞ¼Ñ‹Ñ…, Ğ½Ğ¸ Ğ² Ğ·Ğ°Ğ²Ğ¸ÑĞ¸Ğ¼Ğ¾ÑÑ‚ÑÑ… - ÑÑ‚Ğ¾ ÑĞ¸Ñ€Ğ¾Ñ‚Ñ‹
    orphaned = installed_lower - needed
    
    # Ğ˜ÑĞºĞ»ÑÑ‡Ğ°ĞµĞ¼ ÑĞ¸ÑÑ‚ĞµĞ¼Ğ½Ñ‹Ğµ Ğ¿Ğ°ĞºĞµÑ‚Ñ‹ (pip, setuptools, wheel, etc.)
    system_packages = {'pip', 'setuptools', 'wheel', 'distribute', 'pkg-resources', 'uv'}
    orphaned = orphaned - system_packages
    
    return sorted(list(orphaned))


def prune_orphans(desired_packages: List[str]) -> None:
    """Ğ£Ğ´Ğ°Ğ»ĞµĞ½Ğ¸Ğµ Ğ½ĞµĞ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞµĞ¼Ñ‹Ñ… Ğ¿Ğ°ĞºĞµÑ‚Ğ¾Ğ² (Garbage Collection)"""
    print_banner("Pruning Unused Packages", Colors.YELLOW)
    
    installed = get_installed_packages()
    if not installed:
        print_status("â„¹", "No packages installed", Colors.CYAN)
        return
    
    orphaned = find_orphaned_packages(desired_packages, installed)
    
    if not orphaned:
        print_status("âœ“", "No orphaned packages found", Colors.GREEN)
        return
    
    print_status("ğŸ—‘", f"Found {len(orphaned)} orphaned packages:", Colors.YELLOW)
    for pkg in orphaned:
        print_status("  â€¢", pkg, Colors.RESET)
    
    # Ğ—Ğ°Ğ¿Ñ€Ğ°ÑˆĞ¸Ğ²Ğ°ĞµĞ¼ Ğ¿Ğ¾Ğ´Ñ‚Ğ²ĞµÑ€Ğ¶Ğ´ĞµĞ½Ğ¸Ğµ
    try:
        response = input(f"\n{Colors.YELLOW}Remove these packages? [y/N]: {Colors.RESET}").strip().lower()
        if response != 'y':
            print_status("â†©", "Prune cancelled", Colors.CYAN)
            return
    except (KeyboardInterrupt, EOFError):
        print_status("â†©", "Prune cancelled", Colors.CYAN)
        return
    
    # Ğ£Ğ´Ğ°Ğ»ÑĞµĞ¼ Ğ¿Ğ¾ Ğ¾Ğ´Ğ½Ğ¾Ğ¼Ñƒ Ñ Ğ¾Ğ±Ñ€Ğ°Ñ‚Ğ½Ğ¾Ğ¹ ÑĞ²ÑĞ·ÑŒÑ
    failed = []
    for pkg in orphaned:
        result = run([str(VENV_PYTHON), "-m", "pip", "uninstall", "-y", pkg], capture=True)
        
        if result.returncode == 0:
            print_status("âœ“", f"Removed: {pkg}", Colors.GREEN)
        else:
            print_status("âœ—", f"Failed to remove: {pkg}", Colors.RED)
            failed.append(pkg)
    
    if failed:
        print_status("âš ", f"Failed to remove {len(failed)} packages", Colors.YELLOW)
    else:
        print_status("âœ“", "All orphaned packages removed", Colors.GREEN)


def install_package_atomic(package: str) -> bool:
    """Ğ£ÑÑ‚Ğ°Ğ½Ğ¾Ğ²ĞºĞ° Ğ¾Ğ´Ğ½Ğ¾Ğ³Ğ¾ Ğ¿Ğ°ĞºĞµÑ‚Ğ° Ñ Ñ€Ğ°Ğ·Ğ»Ğ¸Ñ‡Ğ½Ñ‹Ğ¼Ğ¸ ÑÑ‚Ñ€Ğ°Ñ‚ĞµĞ³Ğ¸ÑĞ¼Ğ¸"""
    if not package or not isinstance(package, str):
        log.error(f"Invalid package name: {package}")
        return False
    
    # Ğ’Ğ°Ğ»Ğ¸Ğ´Ğ°Ñ†Ğ¸Ñ Ğ¸Ğ¼ĞµĞ½Ğ¸ Ğ¿Ğ°ĞºĞµÑ‚Ğ° Ğ¿ĞµÑ€ĞµĞ´ ÑƒÑÑ‚Ğ°Ğ½Ğ¾Ğ²ĞºĞ¾Ğ¹
    if not validate_package_name(package.split('[')[0].split('==')[0].split('>=')[0].split('<=')[0]):
        log.error(f"Invalid package name format: {package}")
        return False
    
    log.info(f"Installing: {package}")
    base_cmd = [str(VENV_PYTHON), "-m", "pip", "install", package]
    
    strategies = [
        # 1. Ğ¡Ñ‚Ğ°Ğ½Ğ´Ğ°Ñ€Ñ‚Ğ½Ğ°Ñ ÑƒÑÑ‚Ğ°Ğ½Ğ¾Ğ²ĞºĞ°
        (base_cmd, "standard"),
        # 2. Binary only (Ğ´Ğ»Ñ Windows/Python 3.13)
        (base_cmd + ["--only-binary=:all:"], "binary-only"),
        # 3. Ğ¡ pre-release Ğ²ĞµÑ€ÑĞ¸ÑĞ¼Ğ¸
        (base_cmd + ["--pre"], "pre-release"),
        # 4. Ğ‘ĞµĞ· Ğ·Ğ°Ğ²Ğ¸ÑĞ¸Ğ¼Ğ¾ÑÑ‚ĞµĞ¹ (Ğ¿Ğ¾ÑĞ»ĞµĞ´Ğ½ÑÑ Ğ½Ğ°Ğ´ĞµĞ¶Ğ´Ğ°)
        (base_cmd + ["--no-deps"], "no-deps"),
    ]
    
    for cmd, strategy in strategies:
        result = run(cmd, capture=True, timeout=180)
        if result.returncode == 0:
            log.debug(f"{package} installed via {strategy}")
            return True
    
    return False


def sync_dependencies(packages: List[str], force_update: bool = False) -> None:
    """Ğ¡Ğ¸Ğ½Ñ…Ñ€Ğ¾Ğ½Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ Ğ·Ğ°Ğ²Ğ¸ÑĞ¸Ğ¼Ğ¾ÑÑ‚ĞµĞ¹ Ñ lock Ñ„Ğ°Ğ¹Ğ»Ğ¾Ğ¼"""
    if not packages:
        print_status("â„¹", "No packages to install", Colors.CYAN)
        return
    
    # Ğ’Ğ°Ğ»Ğ¸Ğ´Ğ°Ñ†Ğ¸Ñ ÑĞ¿Ğ¸ÑĞºĞ° Ğ¿Ğ°ĞºĞµÑ‚Ğ¾Ğ²
    valid_packages = []
    for pkg in packages:
        if not pkg or not isinstance(pkg, str):
            log.warning(f"Skipping invalid package: {pkg}")
            continue
        # Ğ˜Ğ·Ğ²Ğ»ĞµĞºĞ°ĞµĞ¼ Ğ¸Ğ¼Ñ Ğ¿Ğ°ĞºĞµÑ‚Ğ° (Ğ±ĞµĞ· Ğ²ĞµÑ€ÑĞ¸Ğ¹ Ğ¸ ÑĞºÑÑ‚Ñ€Ğ°)
        pkg_name = pkg.split('[')[0].split('==')[0].split('>=')[0].split('<=')[0].split('>')[0].split('<')[0].strip()
        if validate_package_name(pkg_name):
            valid_packages.append(pkg)
        else:
            log.warning(f"Skipping invalid package name: {pkg}")
    
    if not valid_packages:
        print_status("âš ", "No valid packages to install after validation", Colors.YELLOW)
        return
    
    packages = valid_packages
    
    ensure_uv()
    
    # 1. Ğ“ĞµĞ½ĞµÑ€Ğ°Ñ†Ğ¸Ñ Lock-Ñ„Ğ°Ğ¹Ğ»Ğ° (Resolve)
    print_banner("Resolving Dependencies", Colors.BLUE)
    
    temp_req = Path("temp_requirements.in")
    temp_req.write_text("\n".join(packages), encoding="utf-8")
    
    compile_cmd = [
        "pip", "compile", 
        str(temp_req), 
        "-o", LOCK_FILE, 
        "--python", str(VENV_PYTHON),
        "--generate-hashes"  # Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ»ÑĞµĞ¼ Ñ…ĞµÑˆĞ¸ Ğ´Ğ»Ñ Ğ±ĞµĞ·Ğ¾Ğ¿Ğ°ÑĞ½Ğ¾ÑÑ‚Ğ¸
    ]
    
    if force_update:
        compile_cmd.append("--upgrade")
    
    print_status("ğŸ”’", "Creating lock file with dependency resolution...", Colors.CYAN)
    res_lock = run_uv(compile_cmd, capture=False, timeout=300)
    temp_req.unlink(missing_ok=True)
    
    if res_lock.returncode != 0:
        print_status("âš ", "Lock file generation failed, using direct install", Colors.YELLOW)
        install_robust_direct(packages)
        return
    
    print_status("âœ“", f"Lock file created: {LOCK_FILE}", Colors.GREEN)
    
    # 2. Sync (Install from Lock)
    print_banner("Synchronizing Environment", Colors.BLUE)
    
    sync_cmd = [
        "pip", "sync", 
        LOCK_FILE, 
        "--python", str(VENV_PYTHON)
    ]
    
    print_status("ğŸ“¦", "Installing packages from lock file...", Colors.CYAN)
    res_sync = run_uv(sync_cmd, capture=False, timeout=600)
    
    if res_sync.returncode == 0:
        print_status("âœ“", "Environment synchronized successfully", Colors.GREEN)
    else:
        print_status("âš ", "UV sync failed, trying atomic fallback", Colors.YELLOW)
        install_robust_direct(packages)


def install_robust_direct(packages: List[str]) -> None:
    """ĞĞ²Ğ°Ñ€Ğ¸Ğ¹Ğ½Ğ°Ñ ÑƒÑÑ‚Ğ°Ğ½Ğ¾Ğ²ĞºĞ° Ğ±ĞµĞ· lock-Ñ„Ğ°Ğ¹Ğ»Ğ° (Ğ°Ñ‚Ğ¾Ğ¼Ğ°Ñ€Ğ½Ğ°Ñ ÑƒÑÑ‚Ğ°Ğ½Ğ¾Ğ²ĞºĞ° ĞºĞ°Ğ¶Ğ´Ğ¾Ğ³Ğ¾ Ğ¿Ğ°ĞºĞµÑ‚Ğ°)"""
    print_banner("ATOMIC FALLBACK INSTALL", Colors.YELLOW)
    
    failed = []
    success = []
    
    total = len(packages)
    for idx, pkg in enumerate(packages, 1):
        print(f"\n[{idx}/{total}] Processing: {pkg}")
        
        if install_package_atomic(pkg):
            print_status("âœ“", f"{pkg}: OK", Colors.GREEN)
            success.append(pkg)
        else:
            print_status("âœ—", f"{pkg}: FAILED", Colors.RED)
            failed.append(pkg)
    
    print()
    print_status("âœ“", f"Successfully installed: {len(success)}/{total}", Colors.GREEN)
    
    if failed:
        print_status("âœ—", f"Failed packages: {len(failed)}/{total}", Colors.RED)
        for pkg in failed:
            print_status("  â€¢", pkg, Colors.RED)
        print(f"\n{Colors.YELLOW}Troubleshooting tips:{Colors.RESET}")
        print("  â€¢ Install Visual C++ Build Tools (Windows)")
        print("  â€¢ Install system dependencies (Linux: build-essential, python3-dev)")
        print("  â€¢ Try using an older Python version")
        print("  â€¢ Check if the package name is correct on PyPI")


def verify_env() -> None:
    """ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ğ·Ğ´Ğ¾Ñ€Ğ¾Ğ²ÑŒÑ Ğ¾ĞºÑ€ÑƒĞ¶ĞµĞ½Ğ¸Ñ"""
    print_banner("Environment Health Check", Colors.BLUE)
    
    checks_passed = 0
    checks_total = 4
    
    # 1. Python Runtime
    print_status("ğŸ”", "Checking Python runtime...", Colors.CYAN)
    result = run([str(VENV_PYTHON), "--version"], capture=True)
    if result.returncode == 0:
        version = result.stdout.strip()
        print_status("âœ“", f"Python runtime OK: {version}", Colors.GREEN)
        checks_passed += 1
    else:
        print_status("âœ—", "Python runtime check failed", Colors.RED)
    
    # 2. Pip availability
    print_status("ğŸ”", "Checking pip availability...", Colors.CYAN)
    result = run([str(VENV_PYTHON), "-m", "pip", "--version"], capture=True)
    if result.returncode == 0:
        print_status("âœ“", "Pip is available", Colors.GREEN)
        checks_passed += 1
    else:
        print_status("âœ—", "Pip check failed", Colors.RED)
    
    # 3. Dependency graph integrity (pip check)
    print_status("ğŸ”", "Checking dependency graph...", Colors.CYAN)
    result = run([str(VENV_PYTHON), "-m", "pip", "check"], capture=True)
    if result.returncode == 0:
        print_status("âœ“", "Dependency graph: OK", Colors.GREEN)
        checks_passed += 1
    else:
        print_status("âš ", "Dependency issues found:", Colors.YELLOW)
        print(result.stdout)
    
    # 4. Smoke test - Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ğ¸Ğ¼Ğ¿Ğ¾Ñ€Ñ‚Ğ° ĞºĞ»ÑÑ‡ĞµĞ²Ñ‹Ñ… Ğ¿Ğ°ĞºĞµÑ‚Ğ¾Ğ²
    print_status("ğŸ”", "Running smoke tests...", Colors.CYAN)
    
    installed = get_installed_packages()
    test_packages = [pkg for pkg in ['requests', 'numpy', 'pandas', 'flask'] 
                     if pkg in installed]
    
    if test_packages:
        smoke_passed = True
        for pkg in test_packages[:3]:  # Ğ¢ĞµÑÑ‚Ğ¸Ñ€ÑƒĞµĞ¼ Ğ¼Ğ°ĞºÑĞ¸Ğ¼ÑƒĞ¼ 3 Ğ¿Ğ°ĞºĞµÑ‚Ğ°
            test_code = f"import {pkg}"
            result = run([str(VENV_PYTHON), "-c", test_code], capture=True, timeout=10)
            if result.returncode != 0:
                print_status("âœ—", f"Failed to import {pkg}", Colors.RED)
                smoke_passed = False
        
        if smoke_passed:
            print_status("âœ“", "Smoke tests passed", Colors.GREEN)
            checks_passed += 1
    else:
        print_status("â„¹", "No packages to test", Colors.CYAN)
        checks_passed += 1
    
    # Ğ˜Ñ‚Ğ¾Ğ³Ğ¾Ğ²Ñ‹Ğ¹ Ñ€ĞµĞ·ÑƒĞ»ÑŒÑ‚Ğ°Ñ‚
    print()
    if checks_passed == checks_total:
        print_status("âœ“", f"All checks passed ({checks_passed}/{checks_total})", Colors.GREEN)
    else:
        print_status("âš ", f"Some checks failed ({checks_passed}/{checks_total})", Colors.YELLOW)


def create_backup() -> None:
    """Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ Ñ€ĞµĞ·ĞµÑ€Ğ²Ğ½Ğ¾Ğ¹ ĞºĞ¾Ğ¿Ğ¸Ğ¸ Ñ‚ĞµĞºÑƒÑ‰ĞµĞ³Ğ¾ Ğ¾ĞºÑ€ÑƒĞ¶ĞµĞ½Ğ¸Ñ"""
    print_banner("Creating Backup", Colors.BLUE)
    
    backup_dir = Path(BACKUP_DIR)
    backup_dir.mkdir(exist_ok=True)
    
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    backup_file = backup_dir / f"backup_{timestamp}.json"
    
    installed = get_installed_packages()
    
    backup_data = {
        "timestamp": timestamp,
        "python_version": platform.python_version(),
        "platform": platform.platform(),
        "packages": installed
    }
    
    with open(backup_file, 'w', encoding='utf-8') as f:
        json.dump(backup_data, f, indent=2)
    
    print_status("âœ“", f"Backup created: {backup_file}", Colors.GREEN)
    print_status("â„¹", f"Saved {len(installed)} packages", Colors.CYAN)


def list_backups() -> List[Path]:
    """Ğ¡Ğ¿Ğ¸ÑĞ¾Ğº Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ñ‹Ñ… Ñ€ĞµĞ·ĞµÑ€Ğ²Ğ½Ñ‹Ñ… ĞºĞ¾Ğ¿Ğ¸Ğ¹"""
    backup_dir = Path(BACKUP_DIR)
    if not backup_dir.exists():
        return []
    
    return sorted(backup_dir.glob("backup_*.json"), reverse=True)


def restore_backup() -> None:
    """Ğ’Ğ¾ÑÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¸Ğµ Ğ¾ĞºÑ€ÑƒĞ¶ĞµĞ½Ğ¸Ñ Ğ¸Ğ· Ñ€ĞµĞ·ĞµÑ€Ğ²Ğ½Ğ¾Ğ¹ ĞºĞ¾Ğ¿Ğ¸Ğ¸"""
    print_banner("Restore from Backup", Colors.BLUE)
    
    backups = list_backups()
    if not backups:
        print_status("â„¹", "No backups found", Colors.CYAN)
        return
    
    print("Available backups:")
    for idx, backup in enumerate(backups, 1):
        try:
            with open(backup, 'r', encoding='utf-8') as f:
                data = json.load(f)
                timestamp = data.get('timestamp', 'unknown')
                pkg_count = len(data.get('packages', {}))
                print(f"  {idx}. {timestamp} ({pkg_count} packages)")
        except (FileNotFoundError, json.JSONDecodeError, KeyError, PermissionError) as e:
            log.debug(f"Failed to read backup {backup.name}: {e}")
            print(f"  {idx}. {backup.name} (corrupted)")
    
    try:
        choice = int(input(f"\n{Colors.CYAN}Select backup to restore [1-{len(backups)}]: {Colors.RESET}"))
        if not 1 <= choice <= len(backups):
            print_status("âœ—", "Invalid choice", Colors.RED)
            return
    except (ValueError, KeyboardInterrupt, EOFError):
        print_status("âœ—", "Invalid input or cancelled", Colors.RED)
        return
    
    backup_file = backups[choice - 1]
    
    try:
        with open(backup_file, 'r', encoding='utf-8') as f:
            data = json.load(f)
        
        packages = data.get('packages', {})
        if not packages:
            print_status("âœ—", "Backup contains no packages", Colors.RED)
            return
        
        print_status("ğŸ“¦", f"Restoring {len(packages)} packages...", Colors.CYAN)
        
        # Ğ¡Ğ¾Ğ·Ğ´Ğ°Ñ‘Ğ¼ Ğ²Ñ€ĞµĞ¼ĞµĞ½Ğ½Ñ‹Ğ¹ requirements Ñ„Ğ°Ğ¹Ğ»
        temp_req = Path("temp_restore_requirements.txt")
        requirements = [f"{name}=={version}" for name, version in packages.items()]
        temp_req.write_text("\n".join(requirements), encoding="utf-8")
        
        # Ğ£ÑÑ‚Ğ°Ğ½Ğ°Ğ²Ğ»Ğ¸Ğ²Ğ°ĞµĞ¼
        result = run([str(VENV_PYTHON), "-m", "pip", "install", "-r", str(temp_req)], 
                    capture=False, timeout=600)
        
        temp_req.unlink(missing_ok=True)
        
        if result.returncode == 0:
            print_status("âœ“", "Backup restored successfully", Colors.GREEN)
        else:
            print_status("âœ—", "Restore failed", Colors.RED)
    
    except (FileNotFoundError, json.JSONDecodeError, KeyError, PermissionError, OSError) as e:
        log.error(f"Error reading backup: {e}")
        print_status("âœ—", f"Error reading backup: {e}", Colors.RED)


def show_stats() -> None:
    """ĞŸĞ¾ĞºĞ°Ğ·Ğ°Ñ‚ÑŒ ÑÑ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºÑƒ Ğ¾ĞºÑ€ÑƒĞ¶ĞµĞ½Ğ¸Ñ"""
    print_banner("Environment Statistics", Colors.CYAN)
    
    installed = get_installed_packages()
    
    print_status("ğŸ“Š", f"Total packages installed: {len(installed)}", Colors.CYAN)
    
    if Path(VENV_NAME).exists():
        try:
            venv_size = sum(f.stat().st_size for f in Path(VENV_NAME).rglob('*') if f.is_file())
            venv_size_mb = venv_size / (1024 * 1024)
            print_status("ğŸ’¾", f"Virtual environment size: {venv_size_mb:.1f} MB", Colors.CYAN)
        except (OSError, PermissionError) as e:
            log.debug(f"Failed to calculate venv size: {e}")
            print_status("âš ", "Could not calculate virtual environment size", Colors.YELLOW)
    
    if Path(LOCK_FILE).exists():
        try:
            lock_time = datetime.fromtimestamp(Path(LOCK_FILE).stat().st_mtime)
            print_status("ğŸ”’", f"Lock file updated: {lock_time.strftime('%Y-%m-%d %H:%M:%S')}", Colors.CYAN)
        except (OSError, ValueError) as e:
            log.debug(f"Failed to get lock file timestamp: {e}")
    
    backups = list_backups()
    print_status("ğŸ’¾", f"Available backups: {len(backups)}", Colors.CYAN)


def main():
    """Ğ“Ğ»Ğ°Ğ²Ğ½Ğ°Ñ Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ñ"""
    try:
        cmd = sys.argv[1].lower() if len(sys.argv) > 1 else "sync"
        
        print(f"{Colors.BOLD}{Colors.MAGENTA}")
        print("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—")
        print(f"â•‘  PyDeploy v{VERSION} - Universal Environment Synchronizer          â•‘")
        print("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
        print(Colors.RESET)
        print(f"{Colors.CYAN}Mode: {cmd.upper()}{Colors.RESET}\n")
        
        # ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° ĞºĞ¾Ğ¼Ğ°Ğ½Ğ´
        if cmd == "verify":
            verify_env()
            return
        
        if cmd == "backup":
            create_backup()
            return
        
        if cmd == "restore":
            restore_backup()
            return
        
        if cmd == "stats":
            show_stats()
            return
        
        # ĞÑĞ½Ğ¾Ğ²Ğ½Ğ¾Ğ¹ workflow: sync/update/prune
        if not create_venv():
            log.error("Virtual environment creation failed")
            sys.exit(1)
        
        # 1. Ğ¡ĞºĞ°Ğ½Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ¿Ñ€Ğ¾ĞµĞºÑ‚Ğ°
        target_packages = scan_project()
        
        if not target_packages:
            print_status("â„¹", "No external dependencies found in .py files", Colors.CYAN)
            
            if cmd == "prune":
                installed = get_installed_packages()
                if installed:
                    print_status("ğŸ—‘", f"Removing all {len(installed)} packages (project has no dependencies)", Colors.YELLOW)
                    prune_orphans([])
            return
        
        # 2. ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° ĞºĞ¾Ğ¼Ğ°Ğ½Ğ´
        if cmd == "prune":
            prune_orphans(target_packages)
        
        elif cmd in ["sync", "update"]:
            # Ğ¡Ğ¾Ğ·Ğ´Ğ°Ñ‘Ğ¼ Ğ±ÑĞºĞ°Ğ¿ Ğ¿ĞµÑ€ĞµĞ´ ÑĞ¸Ğ½Ñ…Ñ€Ğ¾Ğ½Ğ¸Ğ·Ğ°Ñ†Ğ¸ĞµĞ¹
            installed = get_installed_packages()
            if installed:
                create_backup()
            
            # Ğ¡Ğ¸Ğ½Ñ…Ñ€Ğ¾Ğ½Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ
            force_update = (cmd == "update")
            sync_dependencies(target_packages, force_update=force_update)
            
            # Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½ÑĞµĞ¼ user-friendly requirements.txt
            Path(REQ_FILE).write_text("\n".join(target_packages), encoding="utf-8")
            print_status("âœ“", f"Requirements saved to {REQ_FILE}", Colors.GREEN)
            
            # Ğ£Ğ´Ğ°Ğ»ÑĞµĞ¼ Ğ½ĞµĞ½ÑƒĞ¶Ğ½Ñ‹Ğµ Ğ¿Ğ°ĞºĞµÑ‚Ñ‹ Ğ¿Ğ¾ÑĞ»Ğµ ÑƒÑÑ‚Ğ°Ğ½Ğ¾Ğ²ĞºĞ¸
            prune_orphans(target_packages)
            
            # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ğ·Ğ´Ğ¾Ñ€Ğ¾Ğ²ÑŒÑ
            verify_env()
        
        else:
            print_status("âœ—", f"Unknown command: {cmd}", Colors.RED)
            print("\nAvailable commands:")
            print("  sync    - Synchronize environment with code (default)")
            print("  update  - Force update all packages to latest versions")
            print("  verify  - Check environment health")
            print("  prune   - Remove unused packages")
            print("  backup  - Create environment backup")
            print("  restore - Restore from backup")
            print("  stats   - Show environment statistics")
            sys.exit(1)
        
        # Ğ¤Ğ¸Ğ½Ğ°Ğ»ÑŒĞ½Ğ¾Ğµ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ
        print()
        print(f"{Colors.BOLD}{Colors.GREEN}{'â•'*70}{Colors.RESET}")
        print(f"{Colors.BOLD}{Colors.GREEN}ğŸš€ Ready! Run: {VENV_PYTHON} main.py{Colors.RESET}")
        print(f"{Colors.BOLD}{Colors.GREEN}{'â•'*70}{Colors.RESET}")
    
    except KeyboardInterrupt:
        print(f"\n{Colors.YELLOW}Operation cancelled by user{Colors.RESET}")
        sys.exit(0)
    
    except Exception as e:
        log.exception("Critical error occurred")
        print(f"\n{Colors.RED}{Colors.BOLD}Critical Error:{Colors.RESET} {e}")
        sys.exit(1)


if __name__ == "__main__":
    main()